第一章 1.17

第四章 处理器体系结构 随便看看1.18

第五章 优化程序性能 1.19-1.20      1.21写lab

第六章 存储器层次结构 1.22

第七章 链接  1.23-1.25 1.26写lab

第八章 异常控制流 1.27-1.29 

第十章 系统级I/O  2.10-2.12 2.13写lab

第十一章 网络编程 学过

第十二章 并发编程 学过 2.14回顾一下

第九章 虚拟内存 2.15-2.17 2.18写lab



4.6 看网课中



# 深入理解计算机系统

## 第一章 计算机系统漫游

* 计算机系统由硬件和系统软件组成

### 1.1 信息就是位+上下文

1. 文本文件以字节序列的形式存储在文件中，只含有`ASCII`码,其他所有文件都成为二进制文件。
2. 数据都是由比特串表示  **everything is bits**
2. Byte and Bit
2. ！！number =>1
2. x<<8 = ? 逻辑左移和算术左移 
2. Unsigned and Signed number

### 1.2 程序被其他程序翻译成不同的格式

1. 高级语言转化为低级机器语言指令->按照可执行目标程序的格式打包->二进制磁盘文件

   ```
   linux> gcc -o hello hello.c
   ```

2.  编译系统：预处理器（文本），编译器（文本），汇编器（二进制），链接器（二进制）

   1. 预处理：处理宏定义
   2. 编译阶段：翻译位汇编语言
   3. 汇编阶段：翻译为机器语言
   4. 链接阶段：合并所有调用函数

### 1.3 了解编译系统如何工作的原因

1. 优化程序性能
2. 理解链接时出现的错误
3. 避免安全漏洞

### 1.4 处理器读并解释储存在内存中的指令

#### 1.4.1 系统的硬件组成

1. 总线：携带信息字节并负责在各个部件间传递
2. I/O设备：Input&Output
3. 主存：执行程序时，用来存放程序和程序处理的数据
4. 处理器（CPU）：核心->PC（程序计数器），解释（执行）存储在主存中的指令的引擎

#### 1.4.2 运行hello程序

1. 在shell中输入`./hello`，shell会将之后输入的字符读入寄存器，再存放到内存中，结束输入后，shell执行一系列指令来加载可执行的文件将其从磁盘复制到主存。
2. 直接存储器存取（`DMA`）

### 1.5 高速缓存cache

1. 针对处理器和主存之间读取数据效率的差异

### 1.6 储存设备形成层次结构

1. 从高到低：寄存器->`L1`高速缓存->`L2`高速缓存->`L3`高速缓存->主存->本地二级存储->远程二级存储（分布式文件系统，Web服务器）

### 1.7 操作系统管理硬件

1. 应用程序和硬件之间的一层插件
2. 功能：
   1. 防止硬件失控的应用程序滥用
   2. 向应用程序提供一个简单一致的机制来控制复杂的硬件

#### 1.7.1 进程

1. 概念：操作系统对一个正在运行的程序的一种抽象
2. 并发运行：一个进程的指令和另一个进程的指令交错执行/单核多核系统
3. 上下文：操作系统保持跟踪进程运行所需要的所有状态的所有信息
4. 从一个进程到另一个进程的转换是由操作系统内核管理的

#### 1.7.2 线程

1. 多个线程组成进程

#### 1.7.3  虚拟内存

1. 抽象概念：为每个进程提供一个假象（每个进程都在独占地使用主存）
2. 大量准确定义的区构成 程序代码和数据->堆->共享库->栈->内核虚拟内存

#### 1.7.4 文件

1. 就是字节序列

### 1.8 系统之间利用网络通信

1. 网络可视作一个I/O设备 

   本地客户端 ------- 远程服务器

### 1.9 

#### 1.9.1 Amdahl定律

想要显著加速整个系统，必须提升全系统中相当大的部分的速度

#### 1.9.2 并发和并行

1. 线程级并发 一个进程中执行多个控制流

   1. 超线程（同时多线程）

2. 指令级并行 同时执行多条指令的属性

3. 单指令、多数据并行 （SIMD并行）

   由特殊硬件实现，允许一条指令产生多个可以并行执行的操作

#### 1.9.3 计算机系统中抽象的重要性

1. 文件是I/O设备的抽象
2. 虚拟内存是对程序存储器的抽象
3. 进程是对一个正在运行的程序的抽象



## 第四章 处理器体系结构

### 4.1 `Y84-64` 指令集体系结构

#### 4.1.1 程序员可见的状态

1. `Y86-64`程序中的每一条指令都会被读取或者修改处理器状态的某些部分
2. 寄存器 条件码 内存 状态码（指示是否出现异常）
3. `Y84-64`程序用虚拟地址来引用内存位置

#### 4.1.2 `Y86-64`指令

1. `movq`:`irmovq`,`rrmovq`,`mrmovq`,`rnmovq` 立即数i、寄存器r、内存m
2. 整数操作指令
3. 跳转指令
4. 条件传送指令
5. `call` `ret` 函数调用
6. `pushq` `popq`出入栈
7. `halt` 暂停执行

#### 4.1.3 指令编码

1.  字节编码分为两个部分，高四位-代码，第四位-功能
2. 程序寄存器每一个都有一个寄存器标识（ID）
3. 指令编码可能附加常数字、寄存器指示符字节

#### 4.1.4 `Y86-64`异常

1. `HLT`、`ADR`非法地址、`INS`非法指令

#### 4.1.5 `Y86-64`程序

1. 不能使用立即数
2. 伪指令

### 4.2 逻辑设计和硬件控制语言`HCL`

#### 4.2.1 逻辑门

AND OR NOT

#### 4.2.2 组合电路和`HCL`布尔表达式

1. 组合电路 

   1.每个输出必须连接到1.一个系统输入2.某个存储器单元的输出3.某个逻辑门的输出

   2.多个逻辑门输出连接在一起可能会使线上的信号矛盾

   3.网必须无环

2. 多路复用器`MUX`

#### 4.2.3 字级的组合电路和`HCL`整数表达式

位级实现，字级相等

算数/逻辑单元

#### 4.2.4 集合关系

```
iexpr in {iexpr1, iexpr2, ..., iexprk}
```

#### 4.2.5 储存器和时钟

1. 组合电路从本质上讲，不存储任何信息，只简单地响应输入信号，产生等于输入地某个函数地输出。
2. 时序电路：时钟，存储器设备：1.时钟寄存器 2.随机访问存储器
3. 寄存器文件：多端口

### 4.3 `Y86-64`的顺序实现

#### 4.3.1 将处理组织成阶段

1. 取指：从内存读取指令字节
2. 译码从寄存器文件读入最多两个操作数
3. 执行：要么执行指令，要么加减栈指针
4. 访存：将数据写入内存
5. 写回：将结果写到寄存器文件
6. 更新PC：将PC设置成下一条指令的地址
7. 处理器无限循环，执行这些阶段

#### 4.3.2 `SEQ`硬件结构

1. 在`SEQ`中，所有的硬件单元的处理都在一个时钟周期内完成
2. 时钟寄存器，硬件单元，控制逻辑块，线路名字，数据连接

#### 4.3.3 `SEQ`的时序

1. 原则：从不回读（处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态

#### 4.3.4 `SEQ`阶段的实现

1. 取指：指令内存硬件单元以PC作为第一个字节的地址，一次从内存中读取出10个字节，第一个字节为指令字节
2. 译码和回写：寄存器文件有四个端口，支持同时进行两个读和写
3. 执行阶段
4. 访存阶段：读写数据，内存读写的地址总是`valE`和`valA`
5. 更新PC阶段：依据指令的类型和是否要选择分支

### 4.4 流水线的通用原理

#### 4.4.1 计算流水线

1. 每个阶段完成指令的一部分
2. 电路延迟 10的-12次方（单位）秒
3. 吞吐量
4. 局限性： 1. 不一致的划分 2.流水线过深，收益反而下降

#### 4.4.4 带反馈的流水线系统

1.  针对一些相邻指令很可能是相关的程序

### 4.5 `Y86-64`的流水线实现

#### 4.5.1 重新安排计算阶段

1. 修改以后被称为`SEQ+`
2. 创建状态寄存器来保存在一条指令执行过程中计算出来的信号
3. 动态地计算PC，不存放程序计数器
4. 称为电路重定时

#### 4.5.2 插入流水线寄存器

1. 尝试在各个阶段插入流水线寄存器

#### 4.5.3 对信号进行重新排列和标号

## 第七章 链接



## 第八章 异常控制流

### 8.1 异常

1. 概念：控制流中的突变
2. 异常表：一张跳转表，进行简介过程调用，到异常处理程序中，一共三种情况
   1. 返回给`curr`
   2. 返回给`next`
   3. 终止

#### 8.1.1 异常处理

1. 异常号：由处理器或者操作系统内核的设计者分配，每种异常异常号**唯一**
2. 异常表由操作系统分配，初始化
3. 过程
   1. 检测到异常
   2. 确认异常号
   3. 处理器触发异常->(通过异常表转到对应程序)
   4. 处理完成后通过“从中断返回”指令选择性地回到对应的程序中

#### 8.1.2 异常的类别

| 类别 | 原因                 | 异步/同步 | 返回行为    |
| ---- | -------------------- | --------- | ----------- |
| 中断 | 来自I/O设备的信号    | 异步      | next        |
| 陷阱 | 有意的异常           | 同步      | next        |
| 故障 | 潜在**可恢复**的错误 | 同步      | `curr`/终止 |
| 终止 | 不可恢复的错误       | 同步      | 终止        |

##### 1.中断

* 通过引脚发信号（中断时电压升高）
* 注意**异步**

##### 2.陷阱和系统调用

* **有意的**
* 用途：系统调用（用户程序和内核之间）
* `syscall`

##### 3.故障

* 由错误情况引起
* 被修正则返回`curr`否则返回到内核中的`abort`->终止
* 例子：缺页异常

##### 4.终止

* 不可恢复的错误引起
* 直接返回`abort`例程

#### 8.1.3 Linux/x86-64系统中的异常

1. 共256种
2. 故障和终止
   1. 除以0（异常号0）
   2. 只读段保护引起的故障（segmentation fault）（异常号13）
   3. 缺页->重复映射页面（异常号14）
   4. 硬件出错（异常号18）

3. 系统调用
   * 每个系统调用都有**唯一**整数号
   * C库实际上已经有很多封装的函数可以调用，不必直接调用`syscall`
   * 系统级函数的概念：系统调用以及相关联的包装函数
   * 所有参数都是通过寄存器传递

### 8.2 进程

* 经典定义：一个执行种程序的实例
* 进程的上下文：程序正确运行所需的状态集合（内核重新启动一个被抢占的进程所需的状态）

#### 8.2.1 逻辑控制流

* 程序计数器（PC）值
* 逻辑控制流：PC值的序列
* 实现：轮流使用处理器，称为多任务(时间分片)

#### 8.2.2 并发流

* 概念：不同的逻辑流的执行在时间上重叠
* 并行流：在不同的处理器核上运行的流

#### 8.2.3 私有地址空间

* 通用结构

#### 8.2.4 用户模式和内核模式

* 处理器通过某个控制寄存器上的模式位来控制进程可访问的地址空间范围和可执行的指令，此时称为内核模式，可以访问任何指令和任意内存位置
* 用户模式没有设置模式位，不允许执行特权命令，但可以通过异常进入内核模式
* Linux种的`/proc`

#### 8.2.5 上下文切换

* 本质：较高层形式的异常控制流
* 上下文的概念
* 调度：内核切换进程的决策
* 步骤
  1. 保存当前进程的上下文
  2. 恢复某个先前被抢占的进程被保存的上下文
  3. 将控制传递给这个新恢复的进程
* 系统调用时可能会发生上下文切换：比如当前进程阻塞
* 中断也可能会发生上下文切换：定时器
* 一个系统调用的例子：
  * read函数（用户模式->内核模式）
  * 等待磁盘读取数据（发生阻塞，此时切换上下文）
  * 数据到达，发送中断信号（内核再次切换上下文）

### 8.3 系统调用错误处理

* 错误处理使代码变得臃肿难以读懂？
* 通过错误报告函数简化->再通过错误处理包装函数进一步简化
* 一般而言小写为系统级函数，大写为包装函数

```c
void unix_error(char *msg){
    fprintf(stderr,"%s:%s\n",msg,strerror(errno));//errno 为设置的全局变量<errno.h>
    exit(0);
}

pid_t Fork(void){
	pid_t pid;
	
	if((pid = fork()) < 0){
		unix_error("Fork error");
	}
	return pid;
}
```

### 8.4 进程控制

#### 8.4.1 获取进程ID

* `getpid` | `getppid` 返回的id不相同

#### 8.4.2 创建和终止进程

* 进程总处于三种状态-运行、停止、终止
* fork函数创建的进程得到的是用户级别的虚拟地址空间，并且是父进程的副本；fork函数被调用一次，返回两次值，分别返回给父进程和子进程，其中在子进程中返回0（因为子进程id总是非零的，用于区分）

* 一个例子，在原书的基础上进行修改

```c
int main(){
    pid_t pid;
    int x = 1;

    pid = Fork();
    if (pid < 0){
        printf("error!");
    }
    if(pid == 0){
        printf("child : x = %d\nI am the chid process, my process ID is %d\n",++x,getpid());
        printf("father\n");
        exit(0);
    }
    printf("parent: x = %d\nI am the parent process, my process ID is %d\n",--x,getpid());
    printf("ok\n");
    exit(0);
}


结果：
parent: x = 0
I am the parent process, my process ID is 3846
child : x = 2
ok
I am the chid process, my process ID is 3860
father
```

* 可以发现
  * 有两个返回值：`pid`=0和`pid`>0
  * 他们具有相同但是独立的地址空间（x)
  * 共享文件：子进程继承了父进程所有打开文件，都输出在屏幕上 
  * 并发执行，是并发的独立进程，交替执行逻辑流指令
* 进程图（刻画程序语句的偏序的一种简单前趋图）

```c
int main(){
	Fork();
    Fork();
    printf("hello\n");
    exit(0);
}

结果：
hello
hello
hello
hello
```

* 上面这个程序，四个进程每一个都调用了一次`printf`函数

#### 8.4.3 回收子进程

* 这件事并不是由内核做，而是交给父进程做，内核只会传递子进程的状态
* 如果父进程终止了：内核会使用`init`进程来回收
* 僵死进程：一个终止但是还未被回收的进程
* `waitpid`函数
  * 判定等待集合的成员->`pid`
  * 修改默认行为->`options`
  * 检查已回收子进程的退出状态->`statusp`（指针）->`status`
  * 错误条件->`pid+errno`
* `wait`函数/简化版`waitpid`（默认`pid`为-1（父进程所有的子进程），`options`是0（不使用））

* 程序不会按照特定顺序回收子进程

* 一个例子

  ```c
  #include <sys/types.h> 
  #include <sys/wait.h> 
  #include <unistd.h> 
  int main() {     
      pid_t pc, pr;     
      pc=Fork();     
      if(pc<0)      
          printf("Error occured on forking.\n");     
      else if(pc==0)     
      {
          sleep(4);
          exit(0);     
      }         
      do     
      {     
          pr=waitpid(pc, NULL, WNOHANG);
          if(pr==0)      
          {         
              printf("No child exited\n");       
              sleep(1);      
          }     
      }while(pr==0);        
      if(pr==pc)      
          printf("successfully release child %d\n", pr);     
      else
          printf("some error occured\n"); 
  }
  
  输出结果：
  No child exited (1s)
  No child exited (1s)
  No child exited (1s)
  No child exited	(1s)
  successfully release child 8579
  ```

#### 8.4.4 让进程休眠

* `sleep`函数

* `pause`函数

  ```c
  // 8.5作业
  void snooze(int end){
      for(int i = 0; i < end;i++  ){
          printf("slept for %d of %d secs\n",i+1,end);
          sleep(1);
      }
      printf("end!");
  }
  ```

#### 8.4.5 加载并运行程序

* `execve`函数

* 调用一次，从不返回（只有出现错误才会返回）

* `argv`参数

* `envp`参数->每一个都是一个`k-v`键值对

* `main`函数的参数：

  * `argc`:`argv[]`的非空数量
  * `argv`：`argv[]`头指针
  * `envp`：`envp[]`的头指针

* `getenv`函数，在`envp[]`中搜索`k-v`键值对，返回指向v的指针

* `setenv`函数：存在则替代，不存在则创建

  ```c
  // 8.6 作业
  int main(int argc,char *argv[],char *envp[]){
      printf("Command-ine arguments:\n");
      for(int i = 0 ;argv[i]!=NULL;i++){
          printf("argv[%2d] : %s\n",i,argv[i]);
      }
  
      printf("Environment variables:\n");
      for(int i = 0;envp[i]!=NULL;i++){
          printf("envp[%2d] : %s\n",i,envp[i]);
      }
  }
  ```

#### 8.4.6 利用`fork`和`execve`运行程序

* 一个简单的shell实现，但是没有实现回收子进程的功能

### 8.5 信号

* 作用：允许进程和内核中断其他信号，通知进程系统发生了一个某种类型的事件
* 每种事件对应不同的信号

#### 8.5.1 信号术语

* 两个步骤
  * 发送信号->由内核实现（更新目的进程上下文的某种状态）
  * 接收信号->目的进程做出相应反应（一个信号最多只能被接受一次，接收了之后内核中地该信号的对应位就会被清除）
* 待处理信号：发送了还没被接收的信号，任何时候一种类型最多一个待处理信号，多的信号会被直接丢弃
* 目的进程可以选择性地阻塞某个信号

#### 8.5.2 发送信号

* 进程组
  * 每个进程都只属于一个进程组，默认父进程和子进程属于同一个进程组
  * `getpgrp`函数返回当前进程组id
  * `setpgid`函数改变进程的id，change（`pid`/第一个参数 to `pgid`/第二个参数（若为0则用`pid`作为进程组id））
* `/bin/kill`指令发送信号
* 从键盘发送信号
  * 作业(job):Unix shell表示对一条命令行求值而创建的进程
  * 前台作业，前台进程组
  * 后台作业，后台进程组
* `kill`函数
  * 参数`pid`，大于0，等于0，小于0三种情况
  * 参数`sig`（要发送的信号）
* `alarm`函数
  * 参数`secs`
  * 默认信号：`SIGALRM`
  * 默认进程：调用进程

#### 8.5.3 接收信号

* 进程模式切换（内核模式->用户模式）时，内核会检查进程的待处理信号集合，如果不为空则会选择一个信号强制让进程接收

* 信号预定义的默认行为

  * 进程终止
  * 进程终止并转储内存
  * 进程停止直到被重启
  * 忽略该信号

* `signal`函数可以修改信号的默认行为，信号`SIGSTOP`，`SIGKILL`不能修改

  * 参数`signum`（信号）

  * 参数handler：

    * `SIG_IGN`->忽略
    * `SIG_DFL`->恢复默认行为
    * 用户自定义的函数（信号处理程序）

  * 例子：

    ```c
    #include <stdio.h>
    #include <signal.h>
    void sigint_handler(int sig){
    
        printf("Caught SIGINT!\n");
        exit(0);
    }
    
    int main(){
        if(signal(SIGINT,sigint_handler) == SIG_ERR){
            printf("error");
        }
        pause();
    
        return 0;
    }
    
    输出：
    ^CCaught SIGINT!  
    ```

#### 8.5.4 阻塞和解除阻塞信号

* 隐式阻塞
  * 另一个信号引起的阻塞
* 显示阻塞
  * 使用`sigprocmask`函数和他的辅助函数来控制阻塞

#### 8.5.5 编写信号处理程序

* 安全的信号处理

  * 处理程序要尽可能简单
  * 在处理程序中只调用异步信号安全的函数
  * 信号处理中唯一安全输出是`write`函数
  * 保存和恢复`errno`，确保其他程序不会修改自己所需的`errno`
  * 阻塞所有的信号
  * 用`volatile`声明全局变量
  * 用`sig_atomic_t`声明标志，这种整型数据类型的读和写保证是原子的（不可中断）
  * 例子：

  ```c
  volatile sig_atomic_t g_flag = 0;
  
  void signal_handler(int signum) {
      g_flag = 1;
  }
  
  int main(void)
  {
      signal(SIGINT, signal_handler);
  
      while( !g_flag ){
          puts( "wait" );
          sleep(1);
      }
  
      puts( "exit" );
  }
  ```

* 正确的信号处理
  * 未处理的信号是不排队的（多了直接丢弃）->逆向思维：如果有未处理信号存在，那么肯定有至少一个信号到达了
  * 一定要回收僵死进程
* 可移植的信号处理
  * 系统调用可被中断
  * 函数语义可能不同
  * `sigaction`函数，过于复杂->`Signal`

#### 8.5.6 同步流以避免并发错误

* 同步的问题：竞争（race)
* 解决办法，在产生竞争之前，使用信号避免竞争->同时也可能因为信号没有及时解除引发新的问题

#### 8.5.7 显示地等待信号

* 一个常见的例子：比如shell会显示地等待用户输入指令
* pause函数和sleep函数都有缺陷->`signsuspend`函数
  * 等价于使用mask后使用pause，但是他是原子性的

