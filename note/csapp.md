第一章 1.17

第四章 处理器体系结构 随便看看1.18

第五章 优化程序性能 1.19-1.20      1.21写lab

第六章 存储器层次结构 1.22

第七章 链接  1.23-1.25 1.26写lab

第八章 异常控制流 1.27-1.29 

第十章 系统级I/O  2.10-2.12 2.13写lab

第十一章 网络编程 学过

第十二章 并发编程 学过 2.14回顾一下

第九章 虚拟内存 2.15-2.17 2.18写lab



# 深入理解计算机系统

## 第一章 计算机系统漫游

* 计算机系统由硬件和系统软件组成

### 1.1 信息就是位+上下文

1. 文本文件以字节序列的形式存储在文件中，只含有`ASCII`码,其他所有文件都成为二进制文件。
2. 数据都是由比特串表示

### 1.2 程序被其他程序翻译成不同的格式

1. 高级语言转化为低级机器语言指令->按照可执行目标程序的格式打包->二进制磁盘文件

   ```
   linux> gcc -o hello hello.c
   ```

2.  编译系统：预处理器（文本），编译器（文本），汇编器（二进制），链接器（二进制）

   1. 预处理：处理宏定义
   2. 编译阶段：翻译位汇编语言
   3. 汇编阶段：翻译为机器语言
   4. 链接阶段：合并所有调用函数

### 1.3 了解编译系统如何工作的原因

1. 优化程序性能
2. 理解链接时出现的错误
3. 避免安全漏洞

### 1.4 处理器读并解释储存在内存中的指令

#### 1.4.1 系统的硬件组成

1. 总线：携带信息字节并负责在各个部件间传递
2. I/O设备：Input&Output
3. 主存：执行程序时，用来存放程序和程序处理的数据
4. 处理器（CPU）：核心->PC（程序计数器），解释（执行）存储在主存中的指令的引擎

#### 1.4.2 运行hello程序

1. 在shell中输入`./hello`，shell会将之后输入的字符读入寄存器，再存放到内存中，结束输入后，shell执行一系列指令来加载可执行的文件将其从磁盘复制到主存。
2. 直接存储器存取（`DMA`）

### 1.5 高速缓存cache

1. 针对处理器和主存之间读取数据效率的差异

### 1.6 储存设备形成层次结构

1. 从高到低：寄存器->`L1`高速缓存->`L2`高速缓存->`L3`高速缓存->主存->本地二级存储->远程二级存储（分布式文件系统，Web服务器）

### 1.7 操作系统管理硬件

1. 应用程序和硬件之间的一层插件
2. 功能：
   1. 防止硬件失控的应用程序滥用
   2. 向应用程序提供一个简单一致的机制来控制复杂的硬件

#### 1.7.1 进程

1. 概念：操作系统对一个正在运行的程序的一种抽象
2. 并发运行：一个进程的指令和另一个进程的指令交错执行/单核多核系统
3. 上下文：操作系统保持跟踪进程运行所需要的所有状态的所有信息
4. 从一个进程到另一个进程的转换是由操作系统内核管理的

#### 1.7.2 线程

1. 多个线程组成进程

#### 1.7.3  虚拟内存

1. 抽象概念：为每个进程提供一个假象（每个进程都在独占地使用主存）
2. 大量准确定义的区构成 程序代码和数据->堆->共享库->栈->内核虚拟内存

#### 1.7.4 文件

1. 就是字节序列

### 1.8 系统之间利用网络通信

1. 网络可视作一个I/O设备 

   本地客户端 ------- 远程服务器

### 1.9 

#### 1.9.1 Amdahl定律

想要显著加速整个系统，必须提升全系统中相当大的部分的速度

#### 1.9.2 并发和并行

1. 线程级并发 一个进程中执行多个控制流

   1. 超线程（同时多线程）

2. 指令级并行 同时执行多条指令的属性

3. 单指令、多数据并行 （SIMD并行）

   由特殊硬件实现，允许一条指令产生多个可以并行执行的操作

#### 1.9.3 计算机系统中抽象的重要性

1. 文件是I/O设备的抽象
2. 虚拟内存是对程序存储器的抽象
3. 进程是对一个正在运行的程序的抽象



## 第四章 处理器体系结构

### 4.1 `Y84-64` 指令集体系结构

#### 4.1.1 程序员可见的状态

1. `Y86-64`程序中的每一条指令都会被读取或者修改处理器状态的某些部分
2. 寄存器 条件码 内存 状态码（指示是否出现异常）
3. `Y84-64`程序用虚拟地址来引用内存位置

#### 4.1.2 `Y86-64`指令

1. `movq`:`irmovq`,`rrmovq`,`mrmovq`,`rnmovq` 立即数i、寄存器r、内存m
2. 整数操作指令
3. 跳转指令
4. 条件传送指令
5. `call` `ret` 函数调用
6. `pushq` `popq`出入栈
7. `halt` 暂停执行

#### 4.1.3 指令编码

1.  字节编码分为两个部分，高四位-代码，第四位-功能
2. 程序寄存器每一个都有一个寄存器标识（ID）
3. 指令编码可能附加常数字、寄存器指示符字节

#### 4.1.4 `Y86-64`异常

1. `HLT`、`ADR`非法地址、`INS`非法指令

#### 4.1.5 `Y86-64`程序

1. 不能使用立即数
2. 伪指令

### 4.2 逻辑设计和硬件控制语言`HCL`

#### 4.2.1 逻辑门

AND OR NOT

#### 4.2.2 组合电路和`HCL`布尔表达式

1. 组合电路 

   1.每个输出必须连接到1.一个系统输入2.某个存储器单元的输出3.某个逻辑门的输出

   2.多个逻辑门输出连接在一起可能会使线上的信号矛盾

   3.网必须无环

2. 多路复用器`MUX`

#### 4.2.3 字级的组合电路和`HCL`整数表达式

位级实现，字级相等

算数/逻辑单元

#### 4.2.4 集合关系

```
iexpr in {iexpr1, iexpr2, ..., iexprk}
```

#### 4.2.5 储存器和时钟

1. 组合电路从本质上讲，不存储任何信息，只简单地响应输入信号，产生等于输入地某个函数地输出。
2. 时序电路：时钟，存储器设备：1.时钟寄存器 2.随机访问存储器
3. 寄存器文件：多端口

### 4.3 `Y86-64`的顺序实现

#### 4.3.1 将处理组织成阶段

1. 取指：从内存读取指令字节
2. 译码从寄存器文件读入最多两个操作数
3. 执行：要么执行指令，要么加减栈指针
4. 访存：将数据写入内存
5. 写回：将结果写到寄存器文件
6. 更新PC：将PC设置成下一条指令的地址
7. 处理器无限循环，执行这些阶段

#### 4.3.2 `SEQ`硬件结构

1. 在`SEQ`中，所有的硬件单元的处理都在一个时钟周期内完成
2. 时钟寄存器，硬件单元，控制逻辑块，线路名字，数据连接

#### 4.3.3 `SEQ`的时序

1. 原则：从不回读（处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态

#### 4.3.4 `SEQ`阶段的实现

1. 取指：指令内存硬件单元以PC作为第一个字节的地址，一次从内存中读取出10个字节，第一个字节为指令字节
2. 译码和回写：寄存器文件有四个端口，支持同时进行两个读和写
3. 执行阶段
4. 访存阶段：读写数据，内存读写的地址总是`valE`和`valA`
5. 更新PC阶段：依据指令的类型和是否要选择分支

### 4.4 流水线的通用原理

#### 4.4.1 计算流水线

1. 每个阶段完成指令的一部分
2. 电路延迟 10的-12次方（单位）秒
3. 吞吐量
4. 局限性： 1. 不一致的划分 2.流水线过深，收益反而下降

#### 4.4.4 带反馈的流水线系统

1.  针对一些相邻指令很可能是相关的程序

### 4.5 `Y86-64`的流水线实现

#### 4.5.1 重新安排计算阶段

1. 修改以后被称为`SEQ+`
2. 创建状态寄存器来保存在一条指令执行过程中计算出来的信号
3. 动态地计算PC，不存放程序计数器
4. 称为电路重定时

#### 4.5.2 插入流水线寄存器

1. 尝试在各个阶段插入流水线寄存器

#### 4.5.3 对信号进行重新排列和标号





