**--最重要的编程思想--**

**If you have the name of the spirit,you get control over it.**

## lec2b-复合数据

### part one

```lisp
(DEFINE (+RAT X Y)
        (MAKE-RAT
         (+ (* (NUMER X)(DENOM Y))
            (* NUMER Y)(DENOM X)))
        (*(DENOM X)(DENOM Y)))
(DEFINE (*RAT X Y)
        (MAKE-RAT
         (*(NUMER X)(NUMER Y))
         (*(DENOM X)(DENOM Y))))
```

* 构造函数：MAKE-RAT

* 选择函数:NUMER(得到分子)  DENOM（得到分母）

  关键问题：既然MAKE-RAT可以构造一个有理数，为什么还需要用选择函数将分子分母抽离出来？

  * 在程序设计时，要将有理数看成一个整体，然后就可以‘name it and hold it’，减少不必要的参数。

### part two

* 封装分子分母

* 序对:

  ![image-20211122230339959](C:\Users\zhangxinyu\AppData\Roaming\Typora\typora-user-images\image-20211122230339959.png)

  ![image-20211122230713670](C:\Users\zhangxinyu\AppData\Roaming\Typora\typora-user-images\image-20211122230713670.png)

  ```lisp
  (DEFINE (MAKE-RAT N D)
          (CONS N D))
  (DEFINE (NUMER X)(CAR X))
  (DEFINE (DENOM X)(CDR X))
  ```

* 在构造函数中约分

  ![image-20211122231529682](C:\Users\zhangxinyu\AppData\Roaming\Typora\typora-user-images\image-20211122231529682.png)

  * 先找到N D的最大公约数G，然后再构造

* 对于+RAT ...来说，MAKE-RAT等就是抽象层--data abstraction 是一种通过构造函数和选择函数将数据对象与它的表示分隔开的编程方法

* 换一种实现方式，不使用抽象（在这里，x,y就是一种序对）：

  ```lisp
  (DEFINE (+RAT X Y)
          (CONS (+ (* (CAR X)(CDR Y))
                   (* (CAR Y)(CDR X)))
                (* (CDR X)(CDR Y))))
  (DEFINE (MAKE-RAT N D)(CONS N D))
  (DEFINE (NUMER X)
          (LET ((G(GCD(CAR X)(CDR X))))
               (/(CAR X)G)))
  (DEFINE (DENOM X)
          (LET ((G(GCD(CAR X)(CDR X))))
               (/(CDR X)G)))
  ```

* 讨论两种方法的优劣

  一个在析取的时候化简，一个在构造的时候化简，看哪个使用的频率低，就使用哪种方法，但是在通常情况下无法预见未来，我们应该怎么做？不要去在乎这些细节。

* **wish编程法**
* DEFINE and LET（全局和局部）

### part three

* 层次系统
  * 每一层独立，方便修改
* 闭包

### part four

* cons的本质是什么，cons的实现

  ```lisp
  (DEFINE (CONS A B)
          (LAMBDA (PICK)
                  (COND
                  	((= PICK 1)A)
                  	((= PICK 2)B))))
  (DEFINE (CAR X)(X 1))
  (DEFINE (CDR X)(X 2))
  ```

  A，B，X...都是复合过程

* 抽象过程和基本过程和数据对象

  或许他们本身并没有太大的区别，过程本身就是概念实体，时对象，独立存在。

## Lec3a-Henderson-Escher的例子

### part one

* 序对

  * 序对中的序对

    ```lisp
    (DEFINT (MAKE-VECTOR N D)(CONS N D))
    
    (DEFINE MAKE-SEGMENT CONS)
    (DEFINE SEG-START CAR)
    (DEFINE SEG-END CDR)
    
    (MAKE-SEG(MAKE-VECTOR 2,3)
             (MAKE-VECTOR 5,1))
    ```

    序对具有闭包的性质，lisp中的数据对象在CONS运算下是封闭的，正是这个性质，我们可以使用它来构造更加复杂的结构

* 表List

  * 本质：一种将序对元素组合起来的约定方式

    ```lisp
    (CONS 1
          (CONS 2
                (CONS 3
                      (CONS 4 nil))))
    
    ```

    等价于

    ```lisp
    (LIST 1 2 3 4)
    ```

    个人觉得，list与数据结构中的list（广义表）非常相似，而CAR和CDR与list(广义表)中的head()，tail()函数非常相似

    ```lisp
    (DEFINE 1-TO-4(LIST 1 2 3 4))
    ```

  * 表的递归策略

    ```lisp
    CDR-ing down a list
    (DEFINE (SCALE-LIST S L)
            (IF(NULL ? L)
               nil
               (CONS{(*(CAR L)S)
                     {(SCALE-LIST S (CDR 1))}})))
    ```

  * 高阶过程MAP(通用过程)实际上MAP是对L进行了拷贝

    （-top down 编程思想）

    ```lisp
    (DEFINE (MAP P L)
            (IF(NULL?L)
               nil
               (CONS(P(CAR L))
                    (MAP P(CDR L)))))
    ```

    ```lisp
    (MAP SQURE 1-TO-4) ->(1,4,9,16)
    (MAP (LAMBDA (X)(+ X 10)) 1-TO-4)->(11 12 13 14)
    ...
    ```

    SCALE-LIST对表MAP的一个特定过程

    ```lisp
    (DEFINE(SCALE-LIST S L)
           (MAP(LAMBDA(ITEM)(* ITEM S))
               L))
    ```

### part two

* 元语言

* 闭包 

* 图像

  图像是一种过程

### part three

* 通过组合实现过程，或者说组合就是一种过程

* 将通用方法抽象成高阶过程

  ```lisp
  (DEFINE(PUSH COMB)
         (LAMBDA(PICT N A)
                ((REPEATED
                  (LAMBDA(P)(COMB PICT P A))
                  N)
                 PICT)))
  (DEFINE RIGHT-PUSH(PUSH BESIDE))
  ```

* 划分的思想

  * 逻辑树
  * 软件工程方法论

* 层次语言

  * 元素
  * 组合子
  * 组合模式
  * 优势：健壮性（每一层的语言都是完整的）区分于划分
  * 重点是设计一种语言而不是工程本身

## Lec3b-符号化求导系统

### part one

**insensitive to small changes**

* 封装

  ```lisp
  (DEFINE(DERIV EXP VAR)
         (COND((CONSTANT?EXP VAR)0)
              ((SAME-VAR? EXP VAR)1)
              ((SUM?)EXP)
              (MAKE-SUM(DERIV (A1 EXP)VAR)
                       DERIV(A2 EXP)VAR)
              ((PRODCUT? EXP)
               (MAKE-SUM
                (MAKE-PRODUCT (M1 EXP)
                              (DERIV (M2 EXP)VAR))
                (MAKE-PRODCUT (DERIV (M1 EXP)VAR)
                              M2 EXP))))         
  ```

* 表结构表示法

  清晰的看见什么是CAR,CDR

  ```lisp
  (DEFINE (CONSTANT? EXP VAR)
          (AND (ATOM> EXP)
               (NOT (EQ? EXP VAR))))
  (DEFINE (SAME0VAR? EXP VAR)
          (AND (ATOM? EXP)
               (EQ? EXP VAR)))
  (DEFINE (SUM? EXP)
          (AND (NOT (ATOM? EXP))
               (EQ (CAR EXP) '+)))
  (DEFINE (MAKE-SUM A1 A2)
          (LIST '+ A1 A2))
  (DEFINE A1 CADR)
  (DEFINE A2 CADDR)
  (+ 3 5)
  CADR -> 3
  CADDR -> 5
  
  (DEFINE (PRODUCT? EXP)
          (AND(NOT(ATOM> EXP))
              (EQ? (CAR EXP)'*)))
  (DEFINE (MAKE-PRODUCT M1 M2)
          (LIST '* M1 M2))
  (DEFINE M1 CAER)
  (DEFINE M2 CADDR)
  ```

* 引用

  引用不透明上下文的典型

### part three

* 分层，抽象

  ```lisp
  (DEFINE (MAKE-SUM A1 A2)
          (COND ((AND (NUMBER? A1)
                      (NUMBER? A2))
                                   (+ A1 A2))
                ((AND (NUMBER? A1)(= A1 0))
                 A2)
                ((AND (NUMBER? A2)(= A2 0))
                 (ELSE (LIST '+ A1 A1)))))
  ```

  如何不用具体的语法，而用抽象的语法抽象的进行

  如何使用抽象屏障控制构造表达式 （’+）

* 代数，代码，数据，语言的一致性

## Lec4a - 匹配模式

### part one

* 用一个自定义的语言表达rule而不是hardcode

* 对rule本身进行abstraction

* 模式通过rule生成骨架，模式是用来匹配原表达式的，应用规则会产生一个新的表达式，这是通过骨架来实例化的。

* 我们将求导规则deriv-rules送入simplifier从而产生dsimp,传给simplifier过程一套规则，它会返回给我们一个过程，根据这些规则对表达式进行化简。

  ```lisp
  (DEFINE DSIMP
          SIMPLIFIER DERIV-RULES)
  ```

### part two

* 输入是表达式和模式，词典（把模式变量映射到匹配的值上）
* 输出是另一个词典（除了旧词典中已有的内容，新词典中还产生的新的匹配）

## Lec4b - 通用运算符

### part one 基于类型的分派

* 通用运算符意味着他会根据数据的种类准确地做出对应的操作

* 让系统以最小的改变来适应变化

* 设计思想：把你的系统分成很多小块，分隔开

* 复数计算

  //使用设计：（一层）

  ```lisp
  (define (+c z1 z2)
      (make-rectangular
       (+ (real-part z1) (real-part z2))
       (+ (imag-part z1) (imag-part z2))))
  
  (define (-c z1 z2)
      (make-rectangular
       (- (real-part z1) (real-part z2))
       (- (imag-part z1) (imag-part z2))))
  
  (define (*c z1 z2)
      (make-polar
       (* (magnitude z1) (magnitude z2))
       (+ (angle z1) (angle z2))))
  
  (define (/c z1 z2)
      (make-polar
       (/ (magnitude z1) (magnitude z2))
       (- (angle z1) (angle z2))))
  ```

  //表示复数：（一层）不同的人可能会表示的不一样，不同的表示方法有不同的优点，将虚实部表示为序对或者用模和副角表示

  ```lisp
  (define (make-rectangular x y)
      (cons x y))
  
  (define (real-part z) (car z))
  
  (define (imag-part z) (cdr z))
  
  (define (make-polar r a)
      (cons (* r (cos a)) (* r (sin a))))
  
  (define (magnitude z)
      (sqrt (+ (square (car z))
               (square (cdr z)))))
  
  (define (angle z)
      (atan (cdr z) (car z)))
  ```

* 系统要做的就是把这些不同的方法结合起来，用垂直屏障分隔

  * 标签

* 带类型的数据 （typed data）

  * 构造方法

  * 判断方法

    ```lisp
    (define (rectangular? z)
        (eq? (typr z) 'rectangular))
    (define (polar? z)
        (eq? (type z) 'polar))
    ```

* 怎么让自己成为系统的一部分？

* 打标签

  ```lisp
  (define (make-rectangular x y)
     (attach-type 'rectangular (cons x y)))
  
  (define (real-part-rectangular z) 
      (car z))
  
  (define (imag-part-rectangular z) 
      (cdr z))
  ...
  
  (define (make-polar r a)
     (attach-type 'polar (cons r a)))
  
  (define (real-part-polar z) 
      (* (car z) (cos (cdr z))))
  
  (define (imag-part-polar z) 
      (* (car z) (sin (cdr z))))
  ...
  ```

* 通用函数

  ```lisp
  (define (real-part z)
      (cond ((rectangular? z)
             (real-part-rectangular 
              (constents z)))
          ((polar? z)
           (real-part-polar
            (contents z)))))
  ...
  ```

### part two 数据导向编程

* key：当有新的变化加入时会发生什么？

  * 通用函数需要全部重写（缺点）

  * 实际上通用函数正是这个系统的缺点，降低了系统的灵活度，通用函数扮演了什么样的角色？

  * 需要修改程序，让他能跳过通用函数这个过程

    ```
    (put key1 key2 value)
    (get key1 key2)
    ```

  * ​	现在需要做的事：

    ```lisp
    (put 'rectangular 'real-part real-part-rectangular)
    (put 'rectangular 'imag-part imag-part-rectangular)
    (put 'rectangular 'magnitude magnitude-rectangular)
    (put 'rectangular 'angle angle-rectangular)
    //新的加入需要做的事情：
    (put 'polar 'real-part real-part-polar)
    ...
    ```

  * 代替通用函数的做法

    ```lisp
    (define (operate op obj)
        (let ((proc (get (type obj) op)))
             (if (not (null? proc))
                 (proc (contents obj))
                 (error "not find any op"))))
    
    (define (real-part obj)
        (operate 'real-part obj))
    
    (define (image-part obj)
        (operate 'imag-part obj))
    ...
    ```

    

  * 实际上的操作过程：这里假设有一个定义好的polar类型的复数z

    ```lisp
    (real-part z)
    ->
    (operate 'real-part z)
    ->
    ((get 'polar 'real-part)(contents z))
    ->
    (real-part-polar z)
    ```

* question：这个z存储了什么？类型？过程？函数？数据？

  * 数据和函数的边界非常模糊
  * 在上面所示的z中存储了数据和polar这个‘标签’，实际上它可以存储别的东西，比如说过程本身，这种解决冲突的办法叫做消息传递

* 命名：重名是否会发生冲突？
  * 只要不是在同一个终端工作，实际上重名不会发生冲突

### part three

* 将整个复数算术系统加入到一个通用算术系统（add sub mul div)它们在更上层

* 有理数算术系统（rat）...如何将函数包加入系统

  * 将其变为带类型的数据

    ```lisp
    (define (make-rat x y)
        (attach-type 'rational (cons x y)))
    
    (put 'rational 'add + rat)
    (put 'rational 'sub - rat)
    ...
    ```

* 同理如何将复数算数加入到系统

  * 再封装一层 ，与外部通信(返回带类型的值，所以可以被get查询）

    ```lisp
    (define (make-complex z)
        (attach-type ' complex z))
    
    (define (+complex z1 z2)
        (make-complex (+c z1 z2)))
    
    (put 'complex 'add +complex)
    -c,*c,/c...
    ```

* 自然数同理

* 如何加入多项式运算

  ```lisp
  (polynomial x <term-list>)
  
  ((15 1) (7 2) (0 5))->x^15+2x^7+5
  
  (define (make-polynomial var term-list)
      (attach-type ' polynomial
                   (cons var term-list)))
  
  (define (*poly p1 p2)
      (if(same-var? (var p1) (var p2))
         (make-polynomial
          (var p1)
          (+ terms (terms-list p1)
             (term-list p2)))
         (error "Polys not in same var")))
  
  (put 'polynomial 'add *poly)
  
  (define (+terms l1 l2)
      (cond 
          ((empty-termlist? l1)l2)
          ((empty-termlist? l2)l1)
          (else
           (let ((t1 (first-term l1))
                 (t2 (first-term l2)))
                (cond
                     ((> (order t1) (order t2))//order：获取次数的选择函数
                      (adjoin-term
                       t1
                       (+terms (rest-terms l1) l2)))
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2
                       (+terms l1 (rest-terms l2))))
                     (else 
                      (adjoin-term
                       (make-term (order t1)
                                  (ADD (coeff t1)
                                       (coeff t2)))
                       (+ terms 
                          (rest-terms l1)
                          (rest-terms l2)))))))))
  ```

  * ADD我们没有把多项式加法归约为某种加法，而是归约为通用运算符ADD，它会有什么样的结果？
    * 系统可以无限递归处理多项式的多项式的加法，多项式的多项式的多项式的加法...
    * 可以理解为多项式是一种构造函数

* 如何添加计算像(x^3+2)/x^2+x这类运算

  * 只需要将+改为ADD ，*改为MUL

    ```lisp
    (define (+rat x y)
        (make-rat
         (ADD (MUL (numer x) (denom y))
              (MUL (denom x) (numer y)))
         (MUL (denom x) (denom y))))
    ```

* 数据为什么被自动化导向了正确的地方？

  * ADD

* 符号代数，消息传递

* 类型转换

## Lec5a - 赋值，状态和副作用

### part one 赋值操作

* `(set! <var> <value>)` !对于系统而言没有意义，只是一个约定表示这是一个赋值操作

* 赋值操作使答案和函数不再是唯一映射的关系

  ```lisp
  (define count 1)
  (define (demo x)
      (set！ count (1 + count))
      (+ x count))
  
  -> (demo 3)
  5
  -> (demo 3)
  6
  //在这个时候count不再是1而是2，所以答案改变了
  ```

* 递归和循环 循环中由依赖关系很容易犯错

  ```lisp
  (define (fact n)
      (define (iter m I)
          (cond 
              (( > I n) m)
              (else (iter (* I m) (+ I 1))))))
  
  (define (fact n)
      (let ((I 1) (m 1))
           (define (loop)
               (cond ((> I n) m)
                   (else
                    (set! m (* I m))
                    (set! I (+ I 1))
                    (loop))))
           (loop)))
  ```

### part two 环境模型

* 元描述

  * 约束,约束变量，自由变量

    ```lisp
    (lambda(y) ((lambda(x) (* x y)) 3))// *=>自由变量
    =>
    (lambda(y) ((lambda(z) (* z y)) 3))
    
    (lambda(x) (* x y))// y=>自由变量
    ```

  * 变量被定义的区域->作用域

  * 约束状态表

  * 规则

* 环境就是一些被连接在一起的框架

### part three

* 计数器

  ```lisp
  (define make-counter
      (lambda(n)
             (lambda()
                    (set! n (1+ n))
                    n)))
  
  (define c1 (make-counter 0))
  (define c2 (make-counter 10))
  
  (c1)
  n->1 => 1
  (c2)
  n->11 => 11
  (c1)
  n->2 => 2
  (c2)
  n->12 => 12
  ```

* 对象，耦合

* Actions and Identity

## Lec5b - 计算对象

### part one

* 电气系统 
  * 抽象
  * 信号
    * 对于每一个电子元件，环境绑定了一个信号
* 如何构建抽象层次

### part two

* 回调函数实现事件通知

* 优先队列AGENDA

  * (MAKE-AGENDA)->new agenda
  * (CURRENT-TIME agenda)->time
  * (EMPTY-AGENDA? agenda)->true/false
  * (ADD-TO-AGENDA! time action agenda)
  * (FIRST-TIME agenda)->action
  * (REMOVE-FIRST-ITEM agenda)
  * 按照时间给事件分类，把agenda组织成由segment构成的表
    * 每个segment包含一个时间，一个待做事件的队列，一个指针
    * 预留一个”头“序对
    * 队列queue
      * (MAKE-QUEUE)->NEW QUEUE
      * (INSERT-QUEUE! QUEUE ITEM)
      * (DELETE-QUEUE! QUEUE)
      * (FRONT-QUEUE QUEUE)
      * (EMPTY-QUEUE? QUEUE)
      * 实现：
        * 一个序对：头指针，尾指针
        * 插入尾部：改变尾指针，改变最后序对指针
        * 。。。
        * (SET-CAR! <PAIR> <VALUE>)
        * (SET-CDR! <PATR> <VALUE>)

* 身份identity

  * 共享

    ```lisp
    (define a (cons 1 2))
    (define b (cons a a))
    now : a=(car b)=(cdr b)
    (set-car! (car b) 3)
    (car a) -> 3
    (cadr b) -> 3
    ```

* 用过程表示cons

  * lambda表达式

    ```lisp
    (define (cons x y)
        (lambda(m) (m x y)))
    (define (car x)
        (x (lambda(a d) a)))
    (define (cdr x)
        (x (lambda(a d) d)))
    
    (car (cons 35 47))
    (car (lambda(m)(m 35 47)))
    ((lambda(m)(m 35 47)) (lambda(a d) a))
    ((lambda(a d) a) 35 47)
    35
    ```

* 用赋值表示cons

  ```lisp
  (define (cons x y)
      (lambda (m)
              (m x
                 y
                 (lambda (n) (set! x n))
                 (lambda (n) (set ! y n)))))
  (define (car x)
      (x (lambda (a d sa sd) a)))
  (define (cdr x)
      (x (lambda (a d d sa sd) d)))
  (define (set-car! x y)
      (x (lambda (a d sa sd) (sa y))))
  (define (set-cdr! x y)
      (x (lambda (a d sa sd) (sd y))))
  ```

  
