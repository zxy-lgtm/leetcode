**--最重要的编程思想--**

**If you have the name of the spirit,you get control over it.**

## lec2b-复合数据

### part one

```lisp
(DEFINE (+RAT X Y)
        (MAKE-RAT
         (+ (* (NUMER X)(DENOM Y))
            (* NUMER Y)(DENOM X)))
        (*(DENOM X)(DENOM Y)))
(DEFINE (*RAT X Y)
        (MAKE-RAT
         (*(NUMER X)(NUMER Y))
         (*(DENOM X)(DENOM Y))))
```

* 构造函数：MAKE-RAT

* 选择函数:NUMER(得到分子)  DENOM（得到分母）

  关键问题：既然MAKE-RAT可以构造一个有理数，为什么还需要用选择函数将分子分母抽离出来？

  * 在程序设计时，要将有理数看成一个整体，然后就可以‘name it and hold it’，减少不必要的参数。

### part two

* 封装分子分母

* 序对:

  ![image-20211122230339959](C:\Users\zhangxinyu\AppData\Roaming\Typora\typora-user-images\image-20211122230339959.png)

  ![image-20211122230713670](C:\Users\zhangxinyu\AppData\Roaming\Typora\typora-user-images\image-20211122230713670.png)

  ```lisp
  (DEFINE (MAKE-RAT N D)
          (CONS N D))
  (DEFINE (NUMER X)(CAR X))
  (DEFINE (DENOM X)(CDR X))
  ```

* 在构造函数中约分

  ![image-20211122231529682](C:\Users\zhangxinyu\AppData\Roaming\Typora\typora-user-images\image-20211122231529682.png)

  * 先找到N D的最大公约数G，然后再构造

* 对于+RAT ...来说，MAKE-RAT等就是抽象层--data abstraction 是一种通过构造函数和选择函数将数据对象与它的表示分隔开的编程方法

* 换一种实现方式，不使用抽象（在这里，x,y就是一种序对）：

  ```lisp
  (DEFINE (+RAT X Y)
          (CONS (+ (* (CAR X)(CDR Y))
                   (* (CAR Y)(CDR X)))
                (* (CDR X)(CDR Y))))
  (DEFINE (MAKE-RAT N D)(CONS N D))
  (DEFINE (NUMER X)
          (LET ((G(GCD(CAR X)(CDR X))))
               (/(CAR X)G)))
  (DEFINE (DENOM X)
          (LET ((G(GCD(CAR X)(CDR X))))
               (/(CDR X)G)))
  ```

* 讨论两种方法的优劣

  一个在析取的时候化简，一个在构造的时候化简，看哪个使用的频率低，就使用哪种方法，但是在通常情况下无法预见未来，我们应该怎么做？不要去在乎这些细节。

* **wish编程法**
* DEFINE and LET（全局和局部）

### part three

* 层次系统
  * 每一层独立，方便修改
* 闭包

### part four

* cons的本质是什么，cons的实现

  ```lisp
  (DEFINE (CONS A B)
          (LAMBDA (PICK)
                  (COND
                  	((= PICK 1)A)
                  	((= PICK 2)B))))
  (DEFINE (CAR X)(X 1))
  (DEFINE (CDR X)(X 2))
  ```

  A，B，X...都是复合过程

* 抽象过程和基本过程和数据对象

  或许他们本身并没有太大的区别，过程本身就是概念实体，时对象，独立存在。

## Lec3a-Henderson-Escher的例子

### part one

* 序对

  * 序对中的序对

    ```lisp
    (DEFINT (MAKE-VECTOR N D)(CONS N D))
    
    (DEFINE MAKE-SEGMENT CONS)
    (DEFINE SEG-START CAR)
    (DEFINE SEG-END CDR)
    
    (MAKE-SEG(MAKE-VECTOR 2,3)
             (MAKE-VECTOR 5,1))
    ```

    序对具有闭包的性质，lisp中的数据对象在CONS运算下是封闭的，正是这个性质，我们可以使用它来构造更加复杂的结构

* 表List

  * 本质：一种将序对元素组合起来的约定方式

    ```lisp
    (CONS 1
          (CONS 2
                (CONS 3
                      (CONS 4 nil))))
    
    ```

    等价于

    ```lisp
    (LIST 1 2 3 4)
    ```

    个人觉得，list与数据结构中的list（广义表）非常相似，而CAR和CDR与list(广义表)中的head()，tail()函数非常相似

    ```lisp
    (DEFINE 1-TO-4(LIST 1 2 3 4))
    ```

  * 表的递归策略

    ```lisp
    CDR-ing down a list
    (DEFINE (SCALE-LIST S L)
            (IF(NULL ? L)
               nil
               (CONS{(*(CAR L)S)
                     {(SCALE-LIST S (CDR 1))}})))
    ```

  * 高阶过程MAP(通用过程)实际上MAP是对L进行了拷贝

    （-top down 编程思想）

    ```lisp
    (DEFINE (MAP P L)
            (IF(NULL?L)
               nil
               (CONS(P(CAR L))
                    (MAP P(CDR L)))))
    ```

    ```lisp
    (MAP SQURE 1-TO-4) ->(1,4,9,16)
    (MAP (LAMBDA (X)(+ X 10)) 1-TO-4)->(11 12 13 14)
    ...
    ```

    SCALE-LIST对表MAP的一个特定过程

    ```lisp
    (DEFINE(SCALE-LIST S L)
           (MAP(LAMBDA(ITEM)(* ITEM S))
               L))
    ```

### part two

* 元语言

* 闭包 

* 图像

  图像是一种过程

### part three

* 通过组合实现过程，或者说组合就是一种过程

* 将通用方法抽象成高阶过程

  ```lisp
  (DEFINE(PUSH COMB)
         (LAMBDA(PICT N A)
                ((REPEATED
                  (LAMBDA(P)(COMB PICT P A))
                  N)
                 PICT)))
  (DEFINE RIGHT-PUSH(PUSH BESIDE))
  ```

* 划分的思想

  * 逻辑树
  * 软件工程方法论

* 层次语言

  * 元素
  * 组合子
  * 组合模式
  * 优势：健壮性（每一层的语言都是完整的）区分于划分
  * 重点是设计一种语言而不是工程本身

## Lec3b-符号化求导系统

### part one

**insensitive to small changes**

* 封装

  ```lisp
  (DEFINE(DERIV EXP VAR)
         (COND((CONSTANT?EXP VAR)0)
              ((SAME-VAR? EXP VAR)1)
              ((SUM?)EXP)
              (MAKE-SUM(DERIV (A1 EXP)VAR)
                       DERIV(A2 EXP)VAR)
              ((PRODCUT? EXP)
               (MAKE-SUM
                (MAKE-PRODUCT (M1 EXP)
                              (DERIV (M2 EXP)VAR))
                (MAKE-PRODCUT (DERIV (M1 EXP)VAR)
                              M2 EXP))))         
  ```

* 表结构表示法

  清晰的看见什么是CAR,CDR

  ```lisp
  (DEFINE (CONSTANT? EXP VAR)
          (AND (ATOM> EXP)
               (NOT (EQ? EXP VAR))))
  (DEFINE (SAME0VAR? EXP VAR)
          (AND (ATOM? EXP)
               (EQ? EXP VAR)))
  (DEFINE (SUM? EXP)
          (AND (NOT (ATOM? EXP))
               (EQ (CAR EXP) '+)))
  (DEFINE (MAKE-SUM A1 A2)
          (LIST '+ A1 A2))
  (DEFINE A1 CADR)
  (DEFINE A2 CADDR)
  (+ 3 5)
  CADR -> 3
  CADDR -> 5
  
  (DEFINE (PRODUCT? EXP)
          (AND(NOT(ATOM> EXP))
              (EQ? (CAR EXP)'*)))
  (DEFINE (MAKE-PRODUCT M1 M2)
          (LIST '* M1 M2))
  (DEFINE M1 CAER)
  (DEFINE M2 CADDR)
  ```

* 引用

  引用不透明上下文的典型

### part three

* 分层，抽象

  ```lisp
  (DEFINE (MAKE-SUM A1 A2)
          (COND ((AND (NUMBER? A1)
                      (NUMBER? A2))
                                   (+ A1 A2))
                ((AND (NUMBER? A1)(= A1 0))
                 A2)
                ((AND (NUMBER? A2)(= A2 0))
                 (ELSE (LIST '+ A1 A1)))))
  ```

  如何不用具体的语法，而用抽象的语法抽象的进行

  如何使用抽象屏障控制构造表达式 （’+）

* 代数，代码，数据，语言的一致性

